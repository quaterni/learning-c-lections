#include <iostream>
#include "Lections.h"
using namespace std;
void lection2()
{
    setlocale(LC_ALL, "Rus");
    int a = 5;
    int b = 10;

    {
        //указатели - переменные содержащие адреса в памяти
        // объявление указателей
        int* pa1 = nullptr;
        auto pa2 = &a; // auto - определяет сам тип указателя, будет int*, & - ссылка на переменную
        cout << "Вывод значения переменной a = 5 : " << a << endl;
        cout << "Вывод адреса указателя pa2 : " << pa2 << endl;
        cout << "Вывод значение типа на который указывает указатель *pa2=a : " << *pa2 << endl;
        pa2 = &b;
        cout << "Вывод значения переменной b = 10: " << b << endl;
        cout << "Вывод нового адреса указателя pa2=&b : " << *pa2 << endl;
        *pa2 = 7;
        cout << "Вывод нового нового значения для указателя *pa2=7 : " << *pa2 << endl;
        cout << "Вывод значения b : " << b << endl;

        //указатель может указывать на любую ячейку в памяти
        auto pa3 = (int*)123;
        cout << "Вывод занчения auto pa3 = (int*)123 : " << pa3 << endl;
        //cout << *pa << endl; - вызов значения приведет к ошибке

        //new - создает новый указатель через конструктор
        pa3 = new int;
        // без конструктора будет мусор
        cout << "Значение уаказателя созданного без конструктора pa3 = new int : " << *pa3 << endl;
        // каждому new нужно удалять память через delete
        //создание указателя через конструктор
        pa3 = new int();
        cout << "Значение уаказателя созданного через конструктор pa3 = new int() : " << *pa3 << endl;
        delete pa3;

        cout << endl << endl;
    }
    {
        //объявление массива
        int ia[] = { 1,2, 3,4,5 };
        int ib[5];
        // sizeof(ia) / sizeof(ia[0]) - запрос длины массива через арифметику указателей
        int length = sizeof(ia) / sizeof(ia[0]);
        const int array_size = 10;
        //создание указателя на массив
        auto pia = new int[array_size];
        for (int i = 0; i < array_size; ++i)
            //pia[i] = i * 3 + 1;
            *(pia + i) = i * 3 + 1;

        //вывод массива через арифметику указателей, страшные циклы
        cout << "Вывод массива:" << endl;
        for (auto i = pia; i < (int*)pia + array_size;)
            cout << *(i++) << endl;

        delete[] pia;
        cout << endl << endl;
    }
    {
        int* pa1 = nullptr;
        // арифметика указателей, префиксные и постфиксные элементы
        cout << "Арифметика указателей на примере int* pa1 = nullptr" << endl;
        cout << endl;
        cout << "Изначальное значение pa1 : " << pa1 << endl;
        cout << "Значение префиксной операции ++pa1 : " << ++pa1 << endl;
        cout << "Значение постфиксной операции pa1++ : " << pa1++ << endl;
        cout << "Итоговое значение pa1 : " << pa1 << endl;
        cout << endl;

        double* pa2 = nullptr;
        cout << "Арифметика указателей на примере вouble* pa2 = nullptr" << endl;
        cout << endl;
        cout << "Изначальное значение pa2 : " << pa2 << endl;
        cout << "Значение префиксной операции ++pa2 : " << ++pa2 << endl;
        cout << "Значение постфиксной операции pa2++ : " << pa2++ << endl;
        cout << "Итоговое значение pa2 : " << pa2 << endl;

        cout << "Арифметика указателей зависит от того, на какой тип данных указывает указатель" << endl;
        cout << endl;

        //нетипизированный указатель, не имеет мин\макс значения памяти
        void* pa3;
        // при передаче теряется информация о типе но данные остаются
        pa3 = pa2;
        // старый способ приведения типов, насильное преобразование указателя в int
        pa1 = (int*)pa3;
    }
    {
        //не позволяет меня значение, но может менять адрес
        const int* pa = &a;
        pa = &b;
        // два const не позваляют менять ни значение, ни адрес
        const int* const pb = &b;
        //pb = &a; 
        cout << pa << endl;
        cout << *pa << endl;

        //Вместо const на си писали директиву #define ИМЯ ЗНАЧЕНИЕ - которая являлась макросом и вставляла в код вместо имени значение
    }
}